# XSM クイックリファレンス

## リテラル

- 数値
  ```
  0b1111  // 2進数
  0q123   // 4進数
  077     // 8進数
  127     // 10進数、0で始まってはいけません。
  0xff    // 16進数
  ```

- 文字
  ```
  'A'
  '\n'   // \nはエスケープシーケンスで改行コード(LF)を表す。
  ```  

- 文字列
  ```
  "ABC"  // 文字の最後はNULL文字(\0)が設定されます。
  ```

- 逐語的文字列
  ```
  `Hello World\n`  // 書いたまま出力されます。\n が改行に置き換わりません。
                   // 文字の最後はNULL文字(\0)が設定されます。
  ```

- エスケープシーケンス
  ```
  \"  - "を入力します
  \a  - ベル
  \b  - バックスペース
  \t  - タブ
  \n  - 改行
  \v  - 垂直タブ
  \f  - 改ページ
  \r  - 復帰
  \0  - NULL文字(0)
  \x  - \xに続く16進数の00～ffで文字コードを直接指定した入力ができます。 
  \e  - \eに続く文字で画面の制御コードを送ることが出来ます。
  \\  - \ 記号
  ```
  ※ エスケープシーケンスはMSX-DOSのシステムコールなどの利用時に限ります。

### コメント

- 行コメント
  ```
  A = 10; // コメント
  ```

- コメントブロック
  ```
  /*
      コメント
  */
  ```

### データ
- レジスタ
  表記は大文字、小文字はどちらでも可。
  通常は符号はなしとして扱っている。

  |レジスタの種類| 表記方法 |
  |---|---|
  |8bitレジスタ| ```A B C D E H L IXH IXL IYH IYL IT※1 RF※1``` |
  |16bitレジスタ| ```AF BC DE HL IX IY SP``` |
  |フラグの表現|```$C $NC $Z $NZ $PE $PO $P $M```|
  |メモリの参照の表記方法| ``` *HL IX[n]```|
  |符号あり表現| ```(+)A (+)HL (singed)A (singed)HL```|

  ※1 IT - Iレジスタ、RF - Rレジスタ。


- 変数

  |型名|内容|
  |---|---|
  |byte|符号なし1バイト数値型|
  |sbyte|符号あり1バイト数値型|
  |int|符号なし2バイト数値型|
  |sint|符号あり2バイト数値型|
  |char|文字型(1バイト)|
  |string|文字列参照型(2バイト)|
    - 配列
    ```
    byte[2] hoge;
    byte[2][4] hoge;
    ```

    - 初期化
  
    初期化はプログラムロード時に1回だけ行われます。
    ```
    char hoge;
    byte hoge = 1;
    int[2] hoge = {1,2};
    byte[2][4] hoge = {{1,2,3,4},{5,6,7,8}};
    byte[] hoge = {1,2};
    char[] hoge = "ABCDEFG";            // 7文字+NULL文字で8バイト 
    char[][] hoge = {"ABCDEFG", "ABC"}; // 2 x 8 = 16バイト 一番長い文字列の長さに合わせます
    string hoge = "ABCDEFG";            // stringは参照型なので2バイトです。以下のような構造を持ちます。
                                        // hoge       : DW hoge_string
                                        // hoge_string: DC "ABCDEFG"
    ```

- 定数
  
    ```
    const int HOGE = 0x0001;    // 数値はプログラム中で置換される
    const string HOGE  = "ABC"; // "ABC"はメモリに配置されます。
    const string HOGE2 = "ABC"; // HOGEと同じなのでHOGEが再利用されます。間違って書き換えると参照個所全部書き換わります。
    ```
    定数は配列が使えません。

- 投影

    ビルドしたファイル内にデータを持たないための仕組みです。
    例えばプログラムが200バイトでワーク領域に変数を1000バイト定義してしまったりすると
    ビルドしたファイルは1200バイトになってしまいます。
    投影型(shadow)を使うとプログラムの外に変数を作成します。

    ```
    shadow int hoge;         // shadowは初期値を設定することが出来ません  
    shadow char[256] hoge;
    ```

    以下の記述でshadowデータを一括で初期化できます。
    ```
    clear _shadow, 0, _shadowSize;
    ```

### 構造体

- 定義
    ```
    struct HOGE {
        byte fuga1;
        int  fuga2;
    } 
    ```
- 宣言と初期化  
    ```
    HOGE hoge = {1,2};
    HOGE[] hoge = {
          {1,2}
        , {3,4}
    };
    ```

### 式

- 代入式(=)

  ニーモニックのLD命令に置き換えられますので、複雑な式は書けません。  
  XSMの代入式では、Z80がサポートする組み合わせ以外の多くの代入式のパターンを疑似的にサポートしています。詳細は命令表を確認してください。
  ```
  A = 1;          // レジスタへの代入
  A = 5 + 2 * 8;  // アセンブル時に値が確定するのであれば計算式を書くことが可能です
  *HL = 1;        // HLの差すメモリへの代入
  hoge = A;       // メモリへ直接代入
  A = hoge.fuga1; // 構造体の参照
  A = hoge[2];    // アセンブル時にアドレスが確定している場合は配列が書けます
  HL = &hoge;     // hogeのアドレスを取得します
  ```

- 演算代入式(+= -= *= /= %=)

  計算を行う場合はこれらの組み合わせで行います。
  ```
  A += 2;
  A += 2 + $C; // キャリー付き(ADC) 
  A -= 3;
  A -= 3 + $C; // キャリー付き(SBC)
  HL -= BC;    // OR A;SBC HL,BC;が実行される
  HL *= A;     // 乗算、除算、余剰算はサブルーチンによりサポートされる
  HL /= BC;
  HL %= D;
  ```
  乗算、除算、余剰算は以下のファイルをimportしている場合に使用できます。
  ```
  import "library/lang/mul.xsm";
  import "library/lang/mulw.xsm";
  import "library/lang/div.xsm";
  import "library/lang/divw.xsm";
  ```

- インクリメント、デクリメント(++ --)
  ```
  A++;
  HL--;
  hoge++;
  ```  

- シフト、ローテーション(>> << >>> <<<)
  ```
  A<<4;     // 4回繰り返し     SLA
  (+)A>>;   // 符号付きシフト   SRA
  A>>>;     // ローテーション   RRC
  HL+$C>>>; // キャリー付き     RR
  ```

- 論理演算式(&= ^= |=)
  ```
  a &= 0b00001111;  // AND
  a ^= 0b00001111;  // XOR
  a |= 0b00001111;  // OR
  ```  

- 関数呼び出し
  ```
  A = hoge("Hello World\n");
  ```

### 関数定義

- 書式

  ```
  // パラメータがレジスタ、もしくはメモリ渡しの場合
  // returnは応答に使用するレジスタ、usingは呼び出しによって壊れるレジスタを定義します
  // ここのusingは未初期化のレジスタを使用時に警告を出すことが目的なので無くてもかまいません。
  function hoge(BC, string fuga1, string fuga2) return A using B,C {
    ...
  }
  
  // パラメータがスタック渡しの場合
  function hoge(string fuga,...) { // "..."でスタックに展開されます
    loop(B) {    // Bはパラメータ数が設定されます
        pop hl;  // パラメータを全て取り出さないと暴走します
    }
  }
  
  // BIOSや常駐処理を呼ぶ際は以下のように定義できます。
  function hoge(C) = 0xe000; // アドレスを指定
  ```

### ラベルとジャンプ

- ラベル
  ```
  hoge:
  ```
- goto
  ```
  goto hoge;
  ```

- call
  ```
  call hoge;
  ```

- return

  ```
  // 戻り値なし、または省略時
  return;
  // 関数に戻り値が設定されている場合は引数を持ちます。
  return 1;
  // function hoge() return A; と定義されていれば return 1 は以下のように展開されます。
  LD A,1
  RET
  // return A; のようになった場合、LD A,Aは省略されます
  ```

- returni / returnn  
  ```
  // 割り込み復帰用のreturnです。こちらは引数を持ちません。
  returni;
  returnn;
  ```

### 制御文

- unsafe   

  A / HLレジスタの暗黙的使用を許可します。  
  unsafeブロック内では代入式、演算代入式、条件式などが大幅に拡張されます。  
  A / HL レジスタを経由することで可能になる式はその代入を省略できます。
  当然ですが A / HLレジスタは壊れます。
  ```
  unsafe {
    *DE = B;
  }
  // これは以下のように展開されます、Aレジスタの元の値は壊れます。
  LD A,B
  LD (DE),A
  
  unsafe {
    BC += DE;
  }
  // これは以下のように展開されます、HLレジレスタの元の値は壊れます。
  LD H,B
  LD L,C
  ADD HL,DE
  LD B,H
  LD C,L

  // さらにunsafeにパラメータBC(またはDE)を与えるとBCレジスタまで暗黙的に使用するようになります。 
  unsaf(BC) {
    HL += 123;
  }
  //通常この処理は以下のように展開しますが、
  PUSH BC
  LD BC,123
  ADD HL,BC
  POP BC
  //unsafe(BC)中だとBCの退避を省略します。
  LD BC,123
  ADD HL,BC
  ```

- if  

  条件分岐処理
  ```
  if(A == 0) {...}
  if(A != 0) {...} else {...}
  if(C >= 10 && C <= 20) ...         // unsafe内なら可能
  if((+)A >= -10 && (+)A <= 10) ...  // 符号付きで判定するときは(+)を付ける
  if(HL >= 10 && HL <= 20) ...       // PUSH/SBCなどを駆使してCP HL,xxを実現していますのでオーバーヘッドがあります。
  if($C) ...    // キャリーフラグ
  if($NZ) ...   // ゼロフラグの否定
  ```  

  ```
  // また、const値と併用して条件付きコンパイルのようなことが可能です。
  const byte hoge = 1;
  if(hoge == 1) {        // ビルド時に結果が決まっているのでif文は生成されない
    // このブロックはビルドされる
  } else {
    // このブロックのコードはビルドされない
  }
  ```  

- for  

  ループ処理
  ```
  for(A = 0; A < 100; A++) {
    …
  }
  ```

- while  

  ループ処理
  ```
  while(A < 10) {
    A++;
  }
  
  // 式を省略すると無限ループになります。
  while() {
  }
  ```

- loop  

  DJNZによるループ処理。制限はありますがループ処理では一番コンパクトになります。
  ```
  loop(10) { // Bレジスタが暗黙的に使用されます。
    ...      // ループ内の処理は126バイトに納めないとアセンブル時にエラーになります。
  }
  // Bレジスタにすでに値が入っている場合でもこのように書いてください。LD B,Bは省略されます。
  loop(B)
  ```

- switch  

  Aレジスタの値別に分岐を行います。
  ```
  // caseの判定にはAレジスタが使われます。例えばswitch(B)とすると、LD A,Bが事前に実行されます。
  switch(A) { 
    case(0) {
      ...        // C言語のswitchのようなbreakは不要です。次のcaseは判定しません。
    }
    case(1,2) {  // 複数条件を書けます
      ...
    }
    default {
      ...
    }
  }
  ```

- continue / break  

  ループ継続または、ループ処理から脱出します。
  ```
  while(A < 10) {
    if( xxxx ) continue; // ループ最初から
    if( xxxx ) break;    // ループ脱出
  }
  ```

- on ～ goto / call / return  

  フラグの内容が成立している場合、ジャンプ命令を実行します。
  ```
  on $Z  goto hogelabel;  // ジャンプ命令
  on $C  call hogelabel;  // サブルーチンコール
  on $NZ return;          // 復帰
  ```

- using

  レジスタの安全なPUSHとPOPを提供します。
  usingを抜ける際に自動的にPOPを実行します。
  ```
  using(HL) {         // PUSH HL
    ...
    using(BC,DE) {    // PUSH BC,DE
      ...
      if(...) return; // 条件成立時 POP DE,BC,HL
    }                 // POP DE,BC
    ...
  }                   // POP HL
  ```

- try

  例外処理です。ただし関数を超えて例外を飛ばすことは出来ません。
  ```
  try {
    if(...) throw 1;  // A = 1が実行される
    return;
  } catch(A) {
    ...               // throw時に実行される処理
  } finally {
    ...               // tryを抜けるときに必ず実行される処理
  }
  ```

- @ ブロック

  インスタントブロック。ブロック内で continue と break が使えるようになります。
  ```
  @ {
      if(xxx) break;    // 終了条件
      continue;         // ループ
  }
  ```


### 命令表
命令表の見方  

〇 - ニーモニックで存在する命令、もしくは複数のコードで代替可能なもの  
△ - unsafeブロック内で使える命令、Aレジスタ または HLレジスタが暗黙的に使われます  
var - 変数(メモリ)を差します  
n - 数値リテラル  

- 代入・演算・比較

8ビット・ロード

| |A|B|C|D|E|H|L|*HL|*BC|*DE|IX[n]|IY[n]|var|n|IXH|IXL|IYH|IYL|IT|RF|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|A = x|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |
|B = x|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ |〇 |〇 |〇 |〇 |〇 | | |
|C = x|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ |〇 |〇 |〇 |〇 |〇 | | |
|D = x|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ |〇 |〇 |〇 |〇 |〇 | | |
|E = x|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ |〇 |〇 |〇 |〇 |〇 | | |
|H = x|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ |〇 |△ |△ |△ |△ | | |
|L = x|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ |〇 |△ |△ |△ |△ | | |
|*HL = x|〇 |〇 |〇 |〇 |〇 |〇 |〇 | | | | | |△ |〇 |△ |△ |△ |△ | | |
|*BC = x|〇 | | |△ |△ |△ |△ | | | | | | |△ |△ |△ |△ |△ | | |
|*DE = x|〇 |△ |△ | | |△ |△ | | | | | | |△ |△ |△ |△ |△ | | |
|IX[n] = x|〇 |〇 |〇 |〇 |〇 |〇 |〇 | | | | | | |〇 | | | | | | |
|IY[n] = x|〇 |〇 |〇 |〇 |〇 |〇 |〇 | | | | | | |〇 | | | | | | |
|var = x|〇 |△ |△ |△ |△ |△ |△ | | | | | |△ |△ |△ |△ |△ |△ | | |
|IXH = x|〇 |〇 |〇 |〇 |〇 |△ |△ | | | | | |△ |〇 |〇 |〇 | | | | |
|IXL = x|〇 |〇 |〇 |〇 |〇 |△ |△ | | | | | |△ |〇 |〇 |〇 | | | | |
|IYH = x|〇 |〇 |〇 |〇 |〇 |△ |△ | | | | | |△ |〇 | | |〇 |〇 | | |
|IYL = x|〇 |〇 |〇 |〇 |〇 |△ |△ | | | | | |△ |〇 | | |〇 |〇 | | |

16ビット・ロード

| |AF|BC|DE|HL|SP|IX|IY|nn|var|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|AF = x| | | | | | | | | |
|BC = x| |〇 |〇 |〇 | |〇 |〇 |〇 |〇 |
|DE = x| |〇 |〇 |〇 | |〇 |〇 |〇 |〇 |
|HL = x| |〇 |〇 |〇 | |〇 |〇 |〇 |〇 |
|SP = x| | | |〇 | |〇 |〇 |〇 |〇 |
|IX = x| |〇 |〇 |〇 | | |〇 |〇 |〇 |
|IY = x| |〇 |〇 |〇 | |〇 | |〇 |〇 |
|var = x| |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |
|PUSH x|〇 |〇 |〇 |〇 | |〇 |〇 | | |
|POP x|〇 |〇 |〇 |〇 | |〇 |〇 | | |

16ビット・キャストロード

| |A|B|C|D|E|H|L|IXH|IXL|IYH|IYL|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|AF = x| | | | | | | | | | | |
|BC = x|△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |
|DE = x|△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |
|HL = x|△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |
|SP = x| | | | | | | | | | | |
|IX = x|△ |△ |△ |△ |△ |△ |△ | | |△ |△ |
|IY = x|△ |△ |△ |△ |△ |△ |△ |△ |△ | | |
|var = x|△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |

8ビット算術・論理演算

| |A|B|C|D|E|H|L|*HL|*BC|*DE|IX[n]|IY[n]|var|n|IXH|IXL|IYH|IYL|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|A += x|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ |〇 |〇 |〇 |〇 |〇 |
|A += x + $C|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ |〇 |〇 |〇 |〇 |〇 |
|A -= x|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ |〇 |〇 |〇 |〇 |〇 |
|A -= x|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ |〇 |〇 |〇 |〇 |〇 |
|A &amp;= x|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ |〇 |〇 |〇 |〇 |〇 |
|A ^= x|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ |〇 |〇 |〇 |〇 |〇 |
|A &#124;= x|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ |〇 |〇 |〇 |〇 |〇 |
|A == x|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ |〇 |〇 |〇 |〇 |〇 |
|x++|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ | |〇 |〇 |〇 |〇 |
|x--|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |△ |〇 |〇 |△ | |〇 |〇 |〇 |〇 |

8ビット算術・論理演算2

| |A|B|C|D|E|H|L|*HL|IX[n]|IY[n]|var|n|IXH|IXL|IYH|IYL|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|B += x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|C += x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|D += x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|E += x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|H += x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|L += x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|var += x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|*BC += x| | | |△ |△ |△ |△ | |△ |△ |△ |△ | | | | |
|*DE += x| |△ |△ | | |△ |△ | |△ |△ |△ |△ | | | | |
|*HL += x| |△ |△ |△ |△ | | | |△ |△ |△ |△ | | | | |
|B += x + $C| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|C += x + $C| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|D += x + $C| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|E += x + $C| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|H += x + $C| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|L += x + $C| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|var += x + $C| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|*BC += x + $C| | | |△ |△ |△ |△ | |△ |△ |△ |△ | | | | |
|*DE += x + $C| |△ |△ | | |△ |△ | |△ |△ |△ |△ | | | | |
|*HL += x + $C| |△ |△ |△ |△ | | | |△ |△ |△ |△ | | | | |
|B -= x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|C -= x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|D -= x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|E -= x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|H -= x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|L -= x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|var -= x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|*BC -= x| | | |△ |△ |△ |△ | |△ |△ |△ |△ | | | | |
|*DE -= x| |△ |△ | | |△ |△ | |△ |△ |△ |△ | | | | |
|*HL -= x| |△ |△ |△ |△ | | | |△ |△ |△ |△ | | | | |
|B -= x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|C -= x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|D -= x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|E -= x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|H -= x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|L -= x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|var -= x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|*BC -= x| | | |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|*DE -= x| |△ |△ | | |△ |△ |△ |△ |△ |△ |△ | | | | |
|*HL -= x| |△ |△ |△ |△ | | | |△ |△ |△ |△ | | | | |
|B == x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|C == x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|D == x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|E == x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|H == x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|L == x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|var == x| |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ | | | | |
|*BC == x| | | |△ |△ |△ |△ | |△ |△ |△ |△ | | | | |
|*DE == x| |△ |△ | | |△ |△ | |△ |△ |△ |△ | | | | |
|*HL == x| |△ |△ |△ |△ | | | |△ |△ |△ |△ | | | | |

16ビット算術演算

| |BC|DE|HL|SP|IX|IY|var|nn|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|HL += x|〇 |〇 |〇 |〇 | | |△ |△ |
|IX += x|〇 |〇 | |〇 |〇 | |△ |△ |
|IY += x|〇 |〇 | |〇 | |〇 |△ |△ |
|HL += x + $C|〇 |〇 |〇 |〇 | | |△ |△ |
|HL -= x - $C|〇 |〇 |〇 |〇 | | |△ |△ |
|x++|〇 |〇 |〇 |〇 |〇 |〇 |△ | |
|x--|〇 |〇 |〇 |〇 |〇 |〇 |△ | |
|HL -= x|〇 |〇 |〇 |〇 | | |△ |△ |
|HL == x|△ |△ | | | | |△ |△ |
|BC += x| |△ | | | | |△ |△ |
|BC += x + $C| |△ | | | | |△ |△ |
|BC -= x| |△ | | | | |△ |△ |
|BC -= x - $C| |△ | | | | |△ |△ |
|BC == x| |△ | | | | |△ |△ |
|DE += x|△ | | | | | |△ |△ |
|DE += x + $C|△ | | | | | |△ |△ |
|DE -= x|△ | | | | | |△ |△ |
|DE -= x - $C|△ | | | | | |△ |△ |
|DE == x|△ | | | | | |△ |△ |
|var += x|△ |△ | | | | |△ |△ |
|var += x + $C|△ |△ | | | | |△ |△ |
|var -= x|△ |△ | | | | |△ |△ |
|var -= x - $C|△ |△ | | | | |△ |△ |
|var == x|△ |△ | | | | |△ |△ |

16ビット算術演算2

| |A|B|C|D|E|IX[n]|IY[n]|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|HL += x|△ |△ |△ |△ |△ |△ |△ |
|IX += x|△ |△ |△ |△ |△ |△ |△ |
|IY += x|△ |△ |△ |△ |△ |△ |△ |
|HL += x + $C|△ |△ |△ |△ |△ |△ |△ |
|HL -= x - $C|△ |△ |△ |△ |△ |△ |△ |
|HL -= x|△ |△ |△ |△ |△ |△ |△ |
|var += x|△ |△ |△ |△ |△ |△ |△ |

16ビット算術演算3

| |A|B|C|D|E|(bc)|(de)|IX[n]|IY[n]|var|n|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|HL *= x|△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |
|BC *= x|△ | | |△ |△ |△ |△ |△ |△ |△ |△ |
|DE *= x|△ |△ |△ | | |△ |△ |△ |△ |△ |△ |
|var *= x|△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |
|HL *= x|△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |
|BC *= x|△ | | |△ |△ |△ |△ |△ |△ |△ |△ |
|DE *= x|△ |△ |△ | | |△ |△ |△ |△ |△ |△ |
|var *= x|△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |
|HL *= x|△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |
|BC *= x|△ | | |△ |△ |△ |△ |△ |△ |△ |△ |
|DE *= x|△ |△ |△ | | |△ |△ |△ |△ |△ |△ |
|var *= x|△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |△ |

16ビット算術演算4

| |BC|DE|var|nn|
|---|:---:|:---:|:---:|:---:|
|HL *= x|△ |△ |△ |△ |
|BC *= x| |△ |△ |△ |
|DE *= x|△ | |△ |△ |
|var *= x|△ |△ |△ |△ |
|HL *= x|△ |△ |△ |△ |
|BC *= x| |△ |△ |△ |
|DE *= x|△ | |△ |△ |
|var *= x|△ |△ |△ |△ |
|HL *= x|△ |△ |△ |△ |
|BC *= x| |△ |△ |△ |
|DE *= x|△ | |△ |△ |
|var *= x|△ |△ |△ |△ |

ローテート・シフト

| |A|B|C|D|E|H|L|*HL|IX[n]|IY[n]|var|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|x<<<|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |
|x>>>|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |
|x+$C<<<|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |
|x+$C>>>|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |
|x<<|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |
|x+$C>>|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |
|x>>|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |△ |
|x+$C<<|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 | | |△ |

16ビット・ローテート・シフト

| |BC|DE|HL|
|---|:---:|:---:|:---:|
|x<<<|〇 |〇 |〇 |
|x>>>|〇 |〇 |〇 |
|x+$C<<<|〇 |〇 |〇 |
|x+$C>>>|〇 |〇 |〇 |
|x<<|〇 |〇 |〇 |
|x+$C>>|〇 |〇 |〇 |
|x>>|〇 |〇 |〇 |


### 内部関数

- データ定義関数(bin/qtr/hex/from)

  ```
  byte[] hoge  = bin("00000000"         // 2進数表記
                   + "11,11,11,11");    // 数字以外は無視されます
  byte[] hoge = qtr("0123,0123");       // 4進数
  byte[] hoge = hex("FF,FF");           // 16進数
  byte[] hoge = from("image.dat");      // ファイル読み込み
  ```

- 分離関数(high/low)
  ```
  int hoge = 0x1234;
  A = high(hoge);     // Aには0x12が入る
  A = low(hoge);      // Aには0x23が入る
  ```

- サイズ取得関数(sizeof)
  ```
  int[10] hoge;
  A = sizeof(hoge);  // Aには20が入る
  ```

- 要素数取得関数(length)
  ```
  int[10] hoge;
  A = length(hoge);  // Aには10が入る
  ```

- オフセット関数(offset)

  構造体メンバーの先頭からのオフセット値を求めます。構造体に配列を使う場合に必須になってくる機能です。

  ```
  // 例 hoge[1].hoge2のアドレスを求める
  struct HOGE {
    byte  fuga1;
    byte  fuga2;
  };
  HOGE[2] hoge;
  HL = hoge;                // hoge[0]のアドレスを取得
  BC = sizeof(HOGE);        // HOGEの構造体サイズを求める
  HL += BC;                 // hoge[1]のアドレスが求まる
  BC = offset(HOGE.fuga2);  // BCには2が入る
  HL += BC;                 // hoge[1].fuga2の先頭アドレス
  ```

- 半角変換関数(half)
  
  ```
  string hoge = half("あいうえお"); // MSXのひらがなASCIIコードに変換されます。
  ```

- ビット判定関数(set/res)

  ```
  // if文内で使える関数です。
  if(set0(A)) { ... } // Aレジスタのビット0がONの場合に条件が成立します。
  if(res7(B)) { ... } // Bレジスタのビット7がOFFの場合に条件が成立します。
  ```

#### その他の命令

一般的なニーモニックと同じように使えますが、一部書式が変更されているものがあります。  
変更されているもののみ詳細を記載しています。

- push
  ```
  push hl;
  push bc,de,hl;  // まとめてpush出来ます
  ```

- pop  
  ```
  pop hl;
  pop bc,de,hl;  // 記述した後ろpopします(hl -> de -> bc)
                 // push合わせると見やすくなるためです 
  ```

- ldi / ldir / ldd / lddr
- cpi / cpir / cpd / cpdr
- nop
- halt
- di
- ei
- im
- ex / exx
  ```
  ex AF,AF;
  ex DE,HL;
  exx;
  ```
  
- daa
- cpl
  ```
  cpl a;
  cpl b;  // unsafe中に使えます
  ```
  
- neg
  ```
  neg a;
  neg b;  // unsafe中に使えます
  ```
  
- ccf
- scf
- rst
- in
- ini / inir / ind / indr
- out
- outi / otir / outd / otdr
- bit
  ```
  bit a,7;
  bit 7,a; // どちらでも同じ意味です。
  ```
  
- set
  ```
  set a,7;
  set 7,a; // どちらでも同じ意味です。
  ```
  
- res
  ```
  res a,7;
  res 7,a; // どちらでも同じ意味です。
  ```

- move
  ```
  byte[5] buf = {0,1,2,3,4};
  byte[5] buf2;
  move buf2, buf;
  move buf2, buf, 5; // サイズ指定も可能
  ```
  内部的にLDIRを実行する命令です。BC/DE/HLレジスタが壊れます。
  
- clear dst, value [,size]
  ```
  byte[5] buf = {0,1,2,3,4};
  clear buf, 0;
  clear buf, 0, 5; // サイズ指定も可能
  ```
  LDIRを応用した初期化命令です。BC/DE/HLレジスタが壊れます。

### マクロ関連

- inline関数定義

  ```
  // パラメータは呼び出し時に使用箇所に埋め込まれます。
  // returnでマクロを終了します。後続のコードは出力されません。
  inline hoge(fuga) return A {
    if(fuga == 1) {a = 10;return a;}
    if(fuga == 2) {a = 20;return a;}
    ...
  }
  
  // このマクロは以下のように展開されます
  hoge(1); // -> a = 10;
  hoge(2); // -> a = 20;
  ```
  
- repeat
  繰り返し処理、ループ系と違い指定された回数同じコードを出力します。
  ```
  // HLにBCを8回足す
  repeat(8) {
    HL += BC;
  }
  ```

- return
  ```
  // マクロから復帰しマクロの実行を停止します。インライン中ではRET命令は発行されません。
  return;
  return a;
  ```

### データ定義文
あまり使い道はないのですがプログラムエリアに直接データを埋め込みます。

- db
  ```
  db 123,0xff;  // バイトデータを埋め込みます
  ```  

- dw
  ```
  dw 1234,0xffff;  // ワードデータを埋め込みます
  ```  

- dc
  ```
  // 通常の文字データと違い、終了文字"\0"は埋め込まれません
  dc "HOGE HOGE\n"; // エスケープシーケンスは処理されます
  dc `HOGE HOGE\n`; // エスケープシーケンスは処理されません
  ```  

### システム定数、システムラベル

- _shadow
  ```
  bc = _shadow; // shadowデータ領域の開始アドレスが取得できます。※importのshadow領域ではありません
  ```

- _shadowSize
  ```
  hl = _shadowSize; // shadow領域のサイズが取得できます。
  clear _shadow, 0, _shadowSize; // shadow型の一括初期化
  ```
  
- _heap
  ```
  hl = _heap;   // プログラムの終わり+1のアドレスを差します。このアドレス以降メモリを自由に使えます。 
  ```

### プリプロセッサ
厳密にはプリプロセッサというわけではないのですが、プログラムではない命令群を便宜上プリプロセッサとします。

- org
  ```
  // それぞれ1ファイルに付き1回だけ有効です。
  org 0x100;          // プログラムを配置するアドレス。デフォルトは0x0100。
  org 0x1000, data;   // データ領域の配置アドレスを決定します。配置先によっては生成されるバイナリが肥大化するので注意してください。
  org 0x2000, shadow; // shadow 型の配置アドレスを決定します。data と違いバイナリサイズに影響はありません。 
  ```
- import
  ```
  import "hoge.xsm";                  // 外部ファイルを取り込みます。取り込まれたファイルはその場に展開されずに後部に追加されます。
  import "hoge.xsm", 0x2000;          // アドレス指定付きで読み込みます、orgと同じです。
  import "hoge.xsm", 0x8000, shadow;  // プログラム全体を指定アドレスにshadowとして読み込みます。これで読み込まれたプログラムはバイナリに含まれることはありません。
                                      // 常駐プログラムを呼ぶ場合に使います。
  ```

- include
  ```
  include "hoge.xsm";                 // 外部ファイルを取り込みその場に挿入されます。
                                      // importで足りる場合はimportを使ってください。
  ```

- debug
  ```
  debug on;   // アセンブル中のソースの出力開始
  debug off;  // アセンブル中のソースの出力停止
  ```

- optimize
  ```
  optimize on;   // 最適化ON、unsafe中に効率のよいソースを出力します(アセンブラデフォルト)。
  optimize off;  // 最適化OFF、最適化が原因で想定通りに動作しない可能性があります。その場合はこちらを試してください。
  ```
