# XSM クイックリファレンス

## リテラル
- 数値
```
0b1111  - 2進数
0q123   - 4進数
077     - 8進数
127     - 10進数、0で始まってはいけません
0xff    - 16進数
```
- 文字
```
'A'
'\n'  - \nはエスケープシーケンスで改行コード(LF)を表す
```  
- 文字列
```
"ABC"
```
- エスケープシーケンス
```
\"  - "を入力します
\a  - ベル
\b  - バックスペース
\t  - タブ
\n  - 改行
\v  - 垂直タブ
\f  - 改ページ
\r  - 復帰
\0  - NULL文字(0)
\x  - \xに続く16進数の00～ffで文字コードを直接指定した入力ができます。 
\e  - エスケープコード、\eに続く文字で画面の制御コードを送ることが出来ます。
\\  - \ 記号
```

### コメント
- 行コメント
```
A = 10; // コメント
```
  
- コメントブロック
```
/*
    コメント
*/
```

### データ
- レジスタ
  表記は大文字、小文字はどちらでも可。
  通常は符号はなしとして扱っている。

  |レジスタの種類| 表記方法 |
  |---|---|
  |8bitレジスタ| ```A B C D E H L IXH IXL IYH IYL IT※1 RF※1``` |
  |16bitレジスタ| ```AF BC DE HL IX IY SP``` |
  |フラグの表現|```$C $NC $Z $NZ $PE $PO $P $M```|
  |メモリの参照の表記方法| ``` *HL IX[n]```|
  |符号あり表現| ```(+)A (+)HL (singed)A (singed)HL```|

  ※1 IT - Iレジスタ、RF - Rレジスタ。

- 変数

  |型名|内容|
  |---|---|
  |byte|符号なし1バイト数値型|
  |sbyte|符号あり1バイト数値型|
  |int|符号なし2バイト数値型|
  |sint|符号あり2バイト数値型|
  |char|文字型(1バイト)|
  |string|文字列参照型(2バイト)|
    - 配列
    ```
    byte[2] hoge;
    byte[2][4] hoge;
    ```

    - 初期化
  
    初期化はプログラムロード時に1回だけ行われます。
    ```
    char hoge;
    byte hoge = 1;
    int[2] hoge = {1,2};
    byte[2][4] hoge = {{1,2,3,4},{5,6,7,8}};
    byte[] hoge = {1,2};
    char[] hoge = "ABCDEFG";            // 7文字+NULL文字で8バイト 
    char[][] hoge = {"ABCDEFG", "ABC"}; // 2 x 8 = 16バイト 一番長い文字列の長さに合わせます
    String hoge = "ABCDEFG";            // stringはメモリ参照型なので2バイトです。
    ```

- 定数
  
    ```
    const int HOGE = 0x0001;
    const string HOGE = "ABC";  // "ABC"はメモリに配置されます。
    ```
    定数は配列が使えません。


- 投影

    ビルドしたファイル内にデータを持たないための仕組みです。
    例えばプログラムが200バイトでワーク領域に変数を1000バイト定義してしまったりすると
    ビルドしたファイルは1200バイトになってしまいます。
    投影型(shadow)を使うとプログラムの外に変数を作成します。

    ```
    shadow int hoge;         // shadowは初期値を設定することが出来ません  
    shadow char[256] hoge;
    ```

    以下の記述でshadowデータを一括で初期化できます。
    ```
    clear _shadow, 0, _shadowSize;
    ```

### 構造体
- 定義
    ```
    struct HOGE {
        byte fuga1;
        int  fuga2;
    } 
    ```
- 宣言と初期化  
    ```
    HOGE hoge = {1,2};
    HOGE[] hoge = {
          {1,2}
        , {3,4}
    };
    ```

### 式
- 代入式(=)

  ニーモニックのLD命令に置き換えられますので、複雑な式は書けません。  
  XSMの代入式では、Z80がサポートする組み合わせ以外の多くの代入式のパターンを疑似的にサポートしています。詳細は命令表を確認してください。
  ```
  A = 1;          // レジスタへの代入
  A = 5 + 2 * 8;  // コンパイル時に値が確定するのであれば計算式を書くことが可能です
  *HL = 1;        // HLの差すメモリへの代入
  hoge = A;       // メモリへ直接代入
  A = hoge.fuga1; // 構造体の参照
  A = hoge[2];    // コンパイル時にアドレスが確定している場合は配列が書けます
  HL = &hoge;     // hogeのアドレスを取得します
  ```
  
- 演算代入式(+= -= *= /= %=)

  計算を行う場合はこれらの組み合わせで行います。
  ```
  A += 2;
  A += 2 + $C; // キャリー付き(ADC) 
  A -= 3;
  A -= 3 + $C; // キャリー付き(SBC)
  HL -= BC;    // OR A;SBC HL,BC;が実行される
  HL *= A;     // 乗算、除算、余剰算はサブルーチンによりサポートされる
  HL /= BC;
  HL %= D;
  ```

- インクリメント、デクリメント(++ --)
  ```
  A++;
  HL--;
  hoge++;
  ```  

- シフト、ローテーション(>> << >>> <<<)
  ```
  A<<4;     // 4回繰り返し     SLA
  (+)A>>;   // 符号付きシフト   SRA
  A>>>;     // ローテーション   RRC
  HL+$C>>>; // キャリー付き     RR
  ```

- 論理演算式(&= ^= |=)
  ```
  a &= 0b00001111;  // AND
  a ^= 0b00001111;  // XOR
  a |= 0b00001111;  // OR
  ```  

- 関数呼び出し
  ```
  A = hoge("Hello World\n");
  ```

### 内部関数
- データ定義関数(bin/qtr/hex/from)
  ```
  byte[] hoge  = bin("00000000"         // 2進数表記
                   + "11,11,11,11");    // 数字以外は無視されます
  byte[] hoge = qtr("0123,0123");       // 4進数
  byte[] hoge = hex("FF,FF");           // 16進数
  byte[] hoge = from("image.dat");      // ファイル読み込み
  ```

- 分離関数(high/low)
  ```
  int hoge = 0x1234;
  A = high(hoge);     // Aには0x12が入る
  A = low(hoge);      // Aには0x23が入る
  ```

- サイズ取得関数(sizeof)
  ```
  byte[100] hoge;
  A = sizeof(hoge);  // Aには100が入る
  ```

- オフセット関数(offset)
  構造体メンバーの先頭からのオフセット値を求めます。構造体に配列を使うので必須になってくる機能です。
  ```
  // 例 hoge[1].hoge2のアドレスを求める
  struct HOGE {
    byte  fuga1;
    byte  fuga2;
  };
  HOGE[2] hoge;
  HL = hoge;                // hoge[0]のアドレスを取得
  BC = sizeof(HOGE);        // HOGEの構造体サイズを求める
  HL += BC;                 // hoge[1]のアドレスが求まる
  BC = offset(HOGE.fuga2);  // BCには2が入る
  HL += BC;                 // hoge[1].fuga2の先頭アドレス
  ```

### 関数定義
- 書式
  ```
  // パラメータがレジスタ、もしくはメモリ渡しの場合
  // returnは応答に使用するレジスタ、usingは呼び出しによって壊れるレジスタを定義します
  function hoge(BC, string fuga1, string fuga2) return A using B,C {
    ...
  }
  
  // パラメータがスタック渡しの場合
  function hoge(string fuga,...) { // "..."でスタックに展開されます
    loop(B) {    // Bはパラメータ数が設定されます
        pop hl;  // パラメータを全て取り出さないと暴走します
    }
  }
  
  // BIOSや常駐処理を呼ぶ際は以下のように定義できます。
  function hoge(C) = 0xe000; // アドレスを指定
  ```


### ラベルとジャンプ
- ラベル
  ```
  hoge:
  ```
- goto
  ```
  goto hoge;
  ```
  
- call
  ```
  call hoge;
  ```
- return
  ```
  // 戻り値なし、または省略時
  return;
  // 関数に戻り値が設定されている場合は引数を持ちます。
  return 1;
  // function hoge() return A; と定義されていれば return 1 は以下のように展開されます。
  LD A,1
  RET
  // return A; のようになった場合、LD A,Aは省略されます
  ```
- returni / returnn  
  割り込み復帰用のreturnです。こちらは引数を持ちません。

### 制御文
- unsafe   

  A / HLレジスタの暗黙的使用を許可します。  
  unsafeブロック内では代入式、演算代入式、条件式などが大幅に拡張されます。  
  A / HL レジスタを経由することで可能になる式はその代入を省略できます。
  当然ですが A / HLレジスタは壊れます。
  ```
  unsafe {
    *DE = B;
  }
  // これは以下のように展開されます、Aレジスタの元の値は壊れます
  LD A,B
  LD DE,A
  
  unsafe {
    BC += DE;
    // これは以下のように展開されます、HLジレスタの元の値は壊れます
    LD H,B
    LD L,C
    ADD HL,DE
    LD B,H
    LD C,L
  }

  // さらにunsafeにパラメータBC(またはDE)を与えるとBCレジスタまで暗黙的に使用するようになります。 
  unsaf(BC) {
    HL += 123;
  }
  //通常この処理は以下のように展開しますが、
  PUSH BC
  LD BC,123
  ADD HL,BC
  POP BC
  //unsafe(BC)中だとBCの退避を省略します。
  LD BC,123
  ADD HL,BC
  ```
  
- if  

  条件分岐処理
  ```
  if(A == 0) {...}
  if(A != 0) {...} else {...}
  if(C >= 10 && C <= 20) ...         // unsafe内なら可能
  if((+)A >= -10 && (+)A <= 10) ...  // 符号付きで判定するときは(+)を付ける
  if(HL >= 10 && HL <= 20) ...       // PUSH/SBCなどを駆使してCP HL,xxを実現していますのでオーバーヘッドがあります。
  if($C) ...    // キャリーフラグ
  if($NZ) ...   // ゼロフラグの否定
  ```  

- for  

  ループ処理
  ```
  for(A = 0; A < 100; A++) {
    …
  }
  ```

- while  

  ループ処理
  ```
  while(A < 10) {
    A++;
  }
  
  // 式を省略すると無限ループになります。
  while() {
  }
  ```
  
- loop  

  DJNZによるループ処理。制限はありますがループ処理では一番コンパクトになります。
  ```
  loop(10) { // Bレジスタが暗黙的に使用されます。
    ...      // ループ内の処理は126バイトに納めないとコンパイル時にエラーになります。
  }
  // Bレジスタにすでに値が入っている場合でもこのように書いてください。LD B,Bは省略されます。
  loop(B)
  ```
  
- switch  

  Aレジスタの値別に分岐を行います。
  ```
  // caseの判定にはAレジスタが使われます。例えばswitch(B)とすると、LD A,Bが事前に実行されます。
  switch(A) { 
    case(0) {
      ...        // C言語のswitchのようなbreakは不要です。次のcaseは判定しません。
    }
    case(1,2) {  // 複数条件を書けます
      ...
    }
    default {
      ...
    }
  }
  ```

- continue / break  

  ループ継続または、ループ処理から脱出します。
  ```
  while(A < 10) {
    if( xxxx ) continue; // ループ最初から
    if( xxxx ) break;    // ループ脱出
  }
  ```

- on ～ goto / call / return  

  フラグの内容が成立している場合、ジャンプ命令を実行します。
  ```
  on $Z  goto hogelabel;  // ジャンプ命令
  on $C  call hogelabel;  // サブルーチンコール
  on $NZ return;          // 復帰
  ```
  
- using

  レジスタの安全なPUSHとPOPを提供します。
  usingを抜ける際に自動的にPOPを実行します。
  ```
  using(HL) {         // PUSH HL
    ...
    using(BC,DE) {    // PUSH BC,DE
      ...
      if(...) return; // 条件成立時 POP DE,BC,HL
    }                 // POP DE,BC
    ...
  }                   // POP HL
  ```

- try

  例外処理です。ただし関数を超えて例外を飛ばすことは出来ません。
  ```
  try {
    if(...) throw 1;  // A = 1が実行される
    return;
  } catch(A) {
    ...               // throw時に実行される処理
  } finally {
    ...               // tryを抜けるときに必ず実行される処理
  }
  ```
- @ ブロック

  インスタントブロック。ブロック内で continue と break が使えるようになります。
  ```
  @ {
      if(xxx) break;    // 終了条件
      continue;         // ループ
  }
  ```


### 命令表
- 演算
  8ビット・ロード

| |A|B|C|D|E|H|L|*HL|*BC|*DE|*IX[n]|*IY[n]|var|n|IXH|IXL|IYH|IYL|IT|RF|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|A = %|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |
|B = %|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● |〇 |〇 |〇 |〇 |〇 | | |
|C = %|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● |〇 |〇 |〇 |〇 |〇 | | |
|D = %|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● |〇 |〇 |〇 |〇 |〇 | | |
|E = %|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● |〇 |〇 |〇 |〇 |〇 | | |
|H = %|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● |〇 |● |● |● |● | | |
|L = %|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● |〇 |● |● |● |● | | |
|*HL = %|〇 |〇 |〇 |〇 |〇 |〇 |〇 | | | | | |● |〇 |● |● |● |● | | |
|*BC = %|〇 | | |● |● |● |● | | | | | | |● |● |● |● |● | | |
|*DE = %|〇 |● |● | | |● |● | | | | | | |● |● |● |● |● | | |
|*IX[n] = %|〇 |〇 |〇 |〇 |〇 |〇 |〇 | | | | | | |〇 | | | | | | |
|*IY[n] = %|〇 |〇 |〇 |〇 |〇 |〇 |〇 | | | | | | |〇 | | | | | | |
|var = %|〇 |● |● |● |● |● |● | | | | | |● |● |● |● |● |● | | |
|IXH = %|〇 |〇 |〇 |〇 |〇 |● |● | | | | | |● |〇 |〇 |〇 | | | | |
|IXL = %|〇 |〇 |〇 |〇 |〇 |● |● | | | | | |● |〇 |〇 |〇 | | | | |
|IYH = %|〇 |〇 |〇 |〇 |〇 |● |● | | | | | |● |〇 | | |〇 |〇 | | |
|IYL = %|〇 |〇 |〇 |〇 |〇 |● |● | | | | | |● |〇 | | |〇 |〇 | | |

16ビット・ロード

| |AF|BC|DE|HL|SP|IX|IY|nn|var|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|AF = %| | | | | | | | | |
|BC = %| |〇 |〇 |〇 | |〇 |〇 |〇 |〇 |
|DE = %| |〇 |〇 |〇 | |〇 |〇 |〇 |〇 |
|HL = %| |〇 |〇 |〇 | |〇 |〇 |〇 |〇 |
|SP = %| | | |〇 | |〇 |〇 |〇 |〇 |
|IX = %| |〇 |〇 |〇 | | |〇 |〇 |〇 |
|IY = %| |〇 |〇 |〇 | |〇 | |〇 |〇 |
|var = %| |〇 |〇 |〇 |〇 |〇 |〇 |● |● |
|PUSH %|〇 |〇 |〇 |〇 | |〇 |〇 | | |
|POP %|〇 |〇 |〇 |〇 | |〇 |〇 | | |

16ビット・キャストロード

| |A|B|C|D|E|H|L|IXH|IXL|IYH|IYL|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|AF = %| | | | | | | | | | | |
|BC = %|● |● |● |● |● |● |● |● |● |● |● |
|DE = %|● |● |● |● |● |● |● |● |● |● |● |
|HL = %|● |● |● |● |● |● |● |● |● |● |● |
|SP = %| | | | | | | | | | | |
|IX = %|● |● |● |● |● |● |● | | |● |● |
|IY = %|● |● |● |● |● |● |● |● |● | | |
|var = %|● |● |● |● |● |● |● |● |● |● |● |

8ビット算術・論理演算

| |A|B|C|D|E|H|L|*HL|*BC|*DE|*IX[n]|*IY[n]|var|n|IXH|IXL|IYH|IYL|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|A += %|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● |〇 |〇 |〇 |〇 |〇 |
|A += % + $C|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● |〇 |〇 |〇 |〇 |〇 |
|A -= %|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● |〇 |〇 |〇 |〇 |〇 |
|A -= %|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● |〇 |〇 |〇 |〇 |〇 |
|A &= %|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● |〇 |〇 |〇 |〇 |〇 |
|A ^= %|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● |〇 |〇 |〇 |〇 |〇 |
|A |= %|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● |〇 |〇 |〇 |〇 |〇 |
|A == %|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● |〇 |〇 |〇 |〇 |〇 |
|%++|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● | |〇 |〇 |〇 |〇 |
|%--|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |● |〇 |〇 |● | |〇 |〇 |〇 |〇 |

8ビット算術・論理演算2

| |A|B|C|D|E|H|L|*HL|*IX[n]|*IY[n]|var|n|IXH|IXL|IYH|IYL|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|B += %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|C += %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|D += %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|E += %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|H += %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|L += %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|var += %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|*BC += %| | | |● |● |● |● | |● |● |● |● | | | | |
|*DE += %| |● |● | | |● |● | |● |● |● |● | | | | |
|*HL += %| |● |● |● |● | | | |● |● |● |● | | | | |
|B += % + $C| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|C += % + $C| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|D += % + $C| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|E += % + $C| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|H += % + $C| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|L += % + $C| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|var += % + $C| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|*BC += % + $C| | | |● |● |● |● | |● |● |● |● | | | | |
|*DE += % + $C| |● |● | | |● |● | |● |● |● |● | | | | |
|*HL += % + $C| |● |● |● |● | | | |● |● |● |● | | | | |
|B -= %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|C -= %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|D -= %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|E -= %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|H -= %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|L -= %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|var -= %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|*BC -= %| | | |● |● |● |● | |● |● |● |● | | | | |
|*DE -= %| |● |● | | |● |● | |● |● |● |● | | | | |
|*HL -= %| |● |● |● |● | | | |● |● |● |● | | | | |
|B -= %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|C -= %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|D -= %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|E -= %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|H -= %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|L -= %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|var -= %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|*BC -= %| | | |● |● |● |● |● |● |● |● |● | | | | |
|*DE -= %| |● |● | | |● |● |● |● |● |● |● | | | | |
|*HL -= %| |● |● |● |● | | | |● |● |● |● | | | | |
|B == %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|C == %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|D == %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|E == %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|H == %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|L == %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|var == %| |● |● |● |● |● |● |● |● |● |● |● | | | | |
|*BC == %| | | |● |● |● |● | |● |● |● |● | | | | |
|*DE == %| |● |● | | |● |● | |● |● |● |● | | | | |
|*HL == %| |● |● |● |● | | | |● |● |● |● | | | | |

16ビット算術演算

| |BC|DE|HL|SP|IX|IY|var|nn|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|HL += %|〇 |〇 |〇 |〇 | | |● |● |
|IX += %|〇 |〇 | |〇 |〇 | |● |● |
|IY += %|〇 |〇 | |〇 | |〇 |● |● |
|HL += % + $C|〇 |〇 |〇 |〇 | | |● |● |
|HL -= % - $C|〇 |〇 |〇 |〇 | | |● |● |
|%++|〇 |〇 |〇 |〇 |〇 |〇 |● | |
|%--|〇 |〇 |〇 |〇 |〇 |〇 |● | |
|HL -= %|〇 |〇 |〇 |〇 | | |● |● |
|HL == %|● |● | | | | |● |● |
|BC += %| |● | | | | |● |● |
|BC += % + $C| |● | | | | |● |● |
|BC -= %| |● | | | | |● |● |
|BC -= % - $C| |● | | | | |● |● |
|BC == %| |● | | | | |● |● |
|DE += %|● | | | | | |● |● |
|DE += % + $C|● | | | | | |● |● |
|DE -= %|● | | | | | |● |● |
|DE -= % - $C|● | | | | | |● |● |
|DE == %|● | | | | | |● |● |
|var += %|● |● | | | | |● |● |
|var += % + $C|● |● | | | | |● |● |
|var -= %|● |● | | | | |● |● |
|var -= % - $C|● |● | | | | |● |● |
|var == %|● |● | | | | |● |● |

16ビット算術演算2

| |A|B|C|D|E|*IX[n]|*IY[n]|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|HL += %|● |● |● |● |● |● |● |
|IX += %|● |● |● |● |● |● |● |
|IY += %|● |● |● |● |● |● |● |
|HL += % + $C|● |● |● |● |● |● |● |
|HL -= % - $C|● |● |● |● |● |● |● |
|HL -= %|● |● |● |● |● |● |● |
|var += %|● |● |● |● |● |● |● |

16ビット算術演算3

| |A|B|C|D|E|(bc)|(de)|*IX[n]|*IY[n]|var|n|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|HL *= %|● |● |● |● |● |● |● |● |● |● |● |
|BC *= %|● | | |● |● |● |● |● |● |● |● |
|DE *= %|● |● |● | | |● |● |● |● |● |● |
|var *= %|● |● |● |● |● |● |● |● |● |● |● |
|HL *= %|● |● |● |● |● |● |● |● |● |● |● |
|BC *= %|● | | |● |● |● |● |● |● |● |● |
|DE *= %|● |● |● | | |● |● |● |● |● |● |
|var *= %|● |● |● |● |● |● |● |● |● |● |● |
|HL *= %|● |● |● |● |● |● |● |● |● |● |● |
|BC *= %|● | | |● |● |● |● |● |● |● |● |
|DE *= %|● |● |● | | |● |● |● |● |● |● |
|var *= %|● |● |● |● |● |● |● |● |● |● |● |

16ビット算術演算4

| |BC|DE|var|nn|
|---|:---:|:---:|:---:|:---:|
|HL *= %|● |● |● |● |
|BC *= %| |● |● |● |
|DE *= %|● | |● |● |
|var *= %|● |● |● |● |
|HL *= %|● |● |● |● |
|BC *= %| |● |● |● |
|DE *= %|● | |● |● |
|var *= %|● |● |● |● |
|HL *= %|● |● |● |● |
|BC *= %| |● |● |● |
|DE *= %|● | |● |● |
|var *= %|● |● |● |● |

ローテート・シフト

| |A|B|C|D|E|H|L|*HL|*IX[n]|*IY[n]|var|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|%<<<|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |
|%>>>|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |
|%+$C<<<|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |
|%+$C>>>|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |
|%<<|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |
|%+$C>>|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |
|%>>|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 |● |
|%+$C<<|〇 |〇 |〇 |〇 |〇 |〇 |〇 |〇 | | |● |

16ビット・ローテート・シフト

| |BC|DE|HL|
|---|:---:|:---:|:---:|
|%<<<|〇 |〇 |〇 |
|%>>>|〇 |〇 |〇 |
|%+$C<<<|〇 |〇 |〇 |
|%+$C>>>|〇 |〇 |〇 |
|%<<|〇 |〇 |〇 |
|%+$C>>|〇 |〇 |〇 |
|%>>|〇 |〇 |〇 |


- その他の疑似命令
    - move
    - clear

### 使用可能なニーモニック
- push
- pop
- ldi / ldir / ldd / lddr
- cpi / cpir / cpd / cpdr
- nop
- halt
- di
- ei
- im
- ex / exx
- daa
- cpl
- neg
- ccf
- scf
- rst
- in
- ini / inir / ind / indr
- out
- outi / otir / outd / otdr
- bit
- set
- res

### システム定数、システムラベル
- _heap
- _shadow
- _shadowSize

### プリプロセッサ
- org
- dataorg
- shadoworg
- import
- debug
- optimize
